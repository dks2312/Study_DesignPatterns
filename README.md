# Study_DesignPatterns
 유튜브 얄팍한 코딩사전 채널의 객체지향 디자인패턴1,2의 예시 코드와 그에 대한 설명 등을 수록하는 리포지토리입니다  
 *처음 얄팍하게 알고서 나중에 심도있게 공부하기 위해 기반을 다지는 중입니다*
 
### 목차
+ [싱글턴 패턴](#싱글턴-패턴-singleton)
+ [전략 패턴](#전략-패턴-strategy)
+ [상태 패턴](#상태-패턴-state)
+ [커맨드 패턴](#커맨드-패턴-command)
+ [어댑터 패턴](#어댑터-패턴-adapter)
+ [프록시 패턴](#프록시-패턴-proxy)

#### 참고한 자료
 + 코드&설명 : [얄팍한 코딩사전](https://www.youtube.com/c/%EC%96%84%ED%8C%8D%ED%95%9C%EC%BD%94%EB%94%A9%EC%82%AC%EC%A0%84)
 + 대문 설명 : [위키 피디아](https://ko.wikipedia.org/)
 
 

## #싱글턴 패턴 (Singleton)
> 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다
  
사용자가 여러분이 만든 앱을 사용하는데 세팅에서 다크모드를 설정해놓으면 다른 페이지로 이동하더라도 이 다크모드가 그대로 유지되어 있어야 하겠죠 **어떤 페이지에 있든 이 세팅을 관리하는 객체는 반드시 같은 것을 사용해야 합니다**

**static으로 클래스 자기 자신의 객체를 넣어주는 변수를 할당 후 private으로 설정하고 get메소드를 만듭니다
get메소드는 static변수가 비어있을 때 세팅해주고 객체를 넘겨줍니다**

### 장단점
* 장점
  + 보통 static으로 설정하기 때문에 어디서든 접근할 수 있어서 **데이터의 공유가 쉽다.** 
  + 한번에 한 자리만 차지하므로 **메모리를 적게 차지한다.**
* 단점
  + 멀티 스레드에서 동시에 호출되거나 생성할 수 있기 때문에 **멀티 스레드 환경에서 사용을 주의해야 한다.** 
  + 한 싱글턴 변수에 많은 역할을 주어지게 된다면 다른 클래스들과의 결합도가 높아져서 **유지보수나 테스트가 힘들다.**



## #전략 패턴 (Strategy)
> 실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다

선택된 모드에 따라서, 이 검색 버튼을 눌렀을 때 실행되는 검색의 방식 결정되는 코드에서 사용될 수 있다
**검색이 이뤄지는 방식, 즉 전략이 수정된다는 점**에서 전략 패턴을 적용할 수 있다

**모드마다 동작하는 모듈로 따로 분리해서 검색 버튼에 갈아 끼워주는 방식으로 적용한다**

### 장단점
* 장점
  + 새로운 로직을 추가하거나 변경할 때, 한번에 **효율적으로 기능 변경이 가능하다**
* 단점
  + 코드가 오히려 길어질 수 있으니 **사용에 주의해야 한다**
 
 
 ## #상태 패턴 (State)
>  상태 기계를 구현하는 행위 소프트웨어 디자인 패턴이다. 이러한 기계는 어떠한 사건(Event)에 의해 한 상태에서 다른 상태로 변화할 수 있다

상태 패턴의 설계 구조는 전략 패턴과 비슷합니다 대략적으로 설명해보자면  
전략 패턴은 **어떤 동일한 틀 안에 있는 특정 작업의 방식**, 모드를 바꿔 줄 때  
상태 패턴은 특정 상태마다 다르게 할 일을, 나아가서 그 상태들 자체를 그 **상태마다 실행시 할 일과 함께** 하나하나 모둘화해서 지정해둘 때 쓰입니다  
  
전략 패턴(모드를 선택하여 검색)  
상태 패턴(전원버튼을 눌렀을 때 화면이 커졌을 때 켜짐/ 꺼졌을 때 켜짐)  

## 장단점
* 장점
  + else-if, swtich문을 확실하게 제거할 수 있어서 **코드가 깔끔해진다**
* 단점
  + 코드가 오히려 길어질 수 있으니 **사용에 주의해야 한다**


## #커맨드 패턴 (Command)
> 요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴이다.
   
커맨드 패턴 또한 전략 패턴과 유사합니다 근본적인 차이는 전략 패턴은 **같은 일을 하되 방식을 갈아끼워지는거라면**  
커맨드 패턴은 **그 하는 일 자체가 다른거**라고 생각하면 됩니다  
  
예제에서는 커맨드를 list로 입력받아 차례로 실행시키고 있습니다 (로봇에게 명령을 입력하고 차례로 실행)  
**Command 인터페이스의 execute추상메소드를 생성하고 로봇이 할 수 있는 범주의 행동들의 동작(클래스)에 implements한다**

## #어댑터 패턴 (Adapter)
> 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해준다.

어댑터란 형식이 **다른 둘 사이에 연결돼서 둘이 호환될 수 있도록 해주는 도구**이다 보통 객체지향에서 인터페이스가 이런 역할을 하고 있다  
<span style="background-color: #f6f8fa"> EX) 요리사와 디저트 담당인 파티셰가 있습니다 매니저는 바쁜 와중에 누구한테는 요리해라, 디저트 만들어라라고 할 수 없기 때문에 파티셰에게 "요리하라"를 "디저트하라"라는 말로 바꿔 들을 수 있게 어댑터를 달아줄 수 있습니다 </span>  
검색버튼 예저처럼 기존의 모드에서 새로운 방식으로 짠 모드를 추가하기 위해선 기존의 모드의 인터페이스를 따라가야합니다 그렇기 때문에 어댑터 클래스를 추가해서 기존의 방식으로 바꿔주는 동작을 작성해야 합니다

## #프록시 패턴 (Proxy)
> 프록시 패턴은 소프트웨어 디자인 패턴의 하나이다 일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스이다. 

인터넷에서 받아와야 해서 시간이 걸리거나 메모리를 많이 차지하는 등의 이유로 객체로 여럿 생성하기 어렵기 때문에 그 클래스의 대리자 역할을 하는 클래스를 따로 두어서 가벼운 일은 대리자가, 무거운 일은 실제 클래스가 한다  
**프록시 클래스를 만들고, 실제 클래스를 받는 변수를 생성한다, 실제 클래스와 똑같은 기능을 하되, 무거운 일은 실제 클래스를 받아와서 변수에 할당한 다음 처리하고(받아왔으면 더 안받아와도 됨), 가벼운건 프록시에서 처리하는 방식으로 짠다**

Facade 패턴 (Facade)
> 설명
추가 설명
Template-method 패턴 (Template)
> 설명
추가 설명
Decorator 패턴 (Decorator)
> 설명
추가 설명
Factory-method 패턴	(Factory)
> 설명
추가 설명
Abstract-factory-method 패턴	(Abstract-factory)
> 설명
추가 설명
Mediator 패턴	(Mediator)
> 설명
추가 설명
